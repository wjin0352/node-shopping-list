/*
//
//  Pu.js
//  ======================================================
//  Created by Yichao 'Peak' Ji (peakji@peak-labs.com).
//  Copyright (c) 2012-2015 Peak Labs. Some rights reserved.
//
*/

var Pu = function() {
	this.version = "2.0.3";
};

var fs = require('fs');
var path = require('path');

/* Logging */
Pu.prototype.log = function(s, fdOrTimestamp, env) {
	var me = this;
	if (env == undefined || global[env] == true) {
		var fileMode = (typeof(fdOrTimestamp) == "string");
		if (fileMode) {
			var directory = fdOrTimestamp.substr(0, fdOrTimestamp.lastIndexOf('/') + 1);
			if (directory.length > 0)
				me.mkdir(directory);
		}
		try {
			if (typeof(s) == "object")
				s = me.pretty(s);
			if (fileMode)
				fs.appendFileSync(fdOrTimestamp, me.time('[', ']') + " " + s + "\n");
			else if (fdOrTimestamp == true)
				console.log(me.time('[', ']') + " " + s);
			else
				console.log(s);
		} catch (e) {
			console.log(s);
		}
	}
};

Pu.prototype.pretty = function(obj) {
	var ret = null;
	try {
		ret = JSON.stringify(obj, false, 4);
		if (ret == "{}" && typeof(obj.toString) == "function") {
			ret = obj.toString();
			if (obj.stack != undefined)
				ret += "\n" + obj.stack;
		}
	} catch (e) {
		ret = "{}";
	}
	return ret;
};

Pu.prototype.help = function(toStr) {
	var r = null,
		buffer = "";
	try {
		r = this.read(__dirname + "/README.md").toString().split('\n');
	} catch (e) {
		buffer += "Pu: Can't find 'README.md'!\n";
	}
	var sc = 0,
		mc = 0;
	for (var i = 0; i < r.length; i++) {
		var line = r[i].trim();
		if (line.indexOf("###") == 0) {
			mc++;
			buffer += line.replace(/#/gi, "") + "\n";
		} else if (line.indexOf("##") == 0) {
			sc++;
			buffer += "\n" + line.replace(/#/gi, "") + "\n----------------------\n";
		}
	}
	buffer += "\nTotal: " + sc + " sections, " + mc + " methods.\n\n";
	if (toStr != true)
		this.log(buffer);
	else
		return buffer;
};

/* String helper */

var _letterOrDigitRange = "\\u0030-\\u0039\\u0041-\\u005a\\u0061-\\u007a\\u00aa\\u00b5\\u00ba\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376-\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u0660-\\u0669\\u066e-\\u066f\\u0671-\\u06d3\\u06d5\\u06e5-\\u06e6\\u06ee-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07c0-\\u07ea\\u07f4-\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f-\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc-\\u09dd\\u09df-\\u09e1\\u09e6-\\u09f1\\u0a05-\\u0a0a\\u0a0f-\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32-\\u0a33\\u0a35-\\u0a36\\u0a38-\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a6f\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2-\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0-\\u0ae1\\u0ae6-\\u0aef\\u0b05-\\u0b0c\\u0b0f-\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32-\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c-\\u0b5d\\u0b5f-\\u0b61\\u0b66-\\u0b6f\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99-\\u0b9a\\u0b9c\\u0b9e-\\u0b9f\\u0ba3-\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0be6-\\u0bef\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58-\\u0c59\\u0c60-\\u0c61\\u0c66-\\u0c6f\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0-\\u0ce1\\u0ce6-\\u0cef\\u0cf1-\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60-\\u0d61\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32-\\u0e33\\u0e40-\\u0e46\\u0e50-\\u0e59\\u0e81-\\u0e82\\u0e84\\u0e87-\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa-\\u0eab\\u0ead-\\u0eb0\\u0eb2-\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f20-\\u0f29\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f-\\u1049\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065-\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u1090-\\u1099\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u17e0-\\u17e9\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u19d0-\\u19d9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1a80-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b50-\\u1b59\\u1b83-\\u1ba0\\u1bae-\\u1be5\\u1c00-\\u1c23\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5-\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u217f\\u2183-\\u2184\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3006\\u3031-\\u3035\\u303b-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6e5\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8d0-\\ua8d9\\ua8f2-\\ua8f7\\ua8fb\\ua900-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf-\\ua9d9\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5-\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
var _letterOrDigitRegExp = new RegExp("[" + _letterOrDigitRange + "]+", "gi");
var _letterOrDigitCustomRegExps = Object.create(null);

Pu.prototype.widthconv = function(str) {
	return str.replace(/[\uff01-\uff5e]/g, function(a) {
		return String.fromCharCode(a.charCodeAt(0) - 65248);
	}).replace(/\u3000/g, " ");
};

Pu.prototype.clean = function(str) {
	var me = this;
	return me.lemma(str, " &\/∀√c♯○〇+").replace(/([^a-zA-Z]) +| +(?=[^a-zA-Z])/gi, "$1");
};

Pu.prototype.lemma = function(str, exceptions) {
	var me = this;
	var normStr = me.widthconv(str.replace(/(\(|（).*(\)|）)/gi, "")).toLowerCase();
	return me.tokenize(normStr, exceptions).join("").replace(/\s+/gi, " ").trim();
};

Pu.prototype.tokenize = function(str, exceptions) {
	var regex = _letterOrDigitRegExp;
	if (exceptions != undefined) {
		if (_letterOrDigitCustomRegExps[exceptions] == undefined)
			_letterOrDigitCustomRegExps[exceptions] = new RegExp("[" + exceptions + _letterOrDigitRange + "]+", "gi");;
		regex = _letterOrDigitCustomRegExps[exceptions];
	}
	return str.match(regex) || [str];
};

Pu.prototype.replace = function(str, mapOrIndex, text) {
	var me = this;
	if (text == undefined)
		text = "";
	if (mapOrIndex == undefined)
		mapOrIndex = "stem";
	if (typeof(mapOrIndex) == "object") {
		var regex = [];
		for (var key in mapOrIndex)
			regex.push(me.regstr(key));
		return str.replace(new RegExp(regex.join('|'), "g"), function(word) {
			return mapOrIndex[word];
		});
	} else if (typeof(mapOrIndex) == "string") {
		var command = mapOrIndex.toLowerCase();

		// DEPRECATED
		if (command == "stem") {
			var clean = me.widthconv(str.replace(/(\(|（).*(\)|）)/gi, "")).replace(/[^a-zA-Z0-9 \/&\u00C0-\u00FF\u0370-\u04FF\u0530-\u074F\u0780-\u9FA5\uac00-\ud7a3]|[。×÷®©℗™℠º∙•・◦●⁃■▪︎◆‘……“”《》［］【】「」『』]/gi, "").replace(/\s+/gi, " ").trim().toLowerCase();
			if (text == true || text.length > 0)
				return clean;
			var strimed = "";
			for (var i = 0; i < clean.length; i++) {
				if (clean[i] != ' ' || (clean[i - 1] >= 'a' && clean[i - 1] <= 'z' && clean[i + 1] >= 'a' && clean[i + 1] <= 'z'))
					strimed += clean[i];
			}
			return strimed;
		} else
			return str.replace(new RegExp(mapOrIndex, "gi"), text);
	} else if (typeof(mapOrIndex) == "number")
		return str.substring(0, mapOrIndex) + text + str.substring(mapOrIndex + 1);
	else
		return str;
}

// DEPRECATED
Pu.prototype.stem = function(str) {
	var me = this;
	return me.replace(str, "stem");
};

Pu.prototype.padnum = function(num, digits) {
	var ns = num + "";
	for (var i = ns.length; i < digits; i++)
		ns = "0" + ns;
	return ns;
};

Pu.prototype.regstr = function(str, dice) {
	var me = this;
	if (!dice)
		return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	else {
		var seg = str.split("");
		for (var i = 0; i < seg.length; i++)
			seg[i] = this.regstr(seg[i], false);
		return seg;
	}
};

Pu.prototype.bracket = function(str, pre, suf) {
	var me = this;
	if (pre == undefined)
		pre = /([ \t\n\s\u3000]*)(\(|（)([ \t\n\s\u3000]*)/gi;
	else if (typeof(pre) == "string")
		pre = new RegExp("([ \\t\\n\\s\\u3000]*)(" + me.regstr(pre, true).join('|') + ")([ \\t\\n\\s\\u3000]*)", "gi");
	if (suf == undefined)
		suf = /([ \t\n\s\u3000]*)(\)|）)([ \t\n\s\u3000]*)/gi;
	else if (typeof(suf) == "string")
		suf = new RegExp("([ \\t\\n\\s\\u3000]*)(" + me.regstr(suf, true).join('|') + ")([ \\t\\n\\s\\u3000]*)", "gi");
	var cleanStr = str.replace(pre, "(").replace(suf, ")"),
		ret = {
			depth: 0
		},
		currentDepth = 0;
	for (var i = 0; i < cleanStr.length; i++) {
		var s = cleanStr[i];
		if (s == "(")
			currentDepth++;
		else if (s == ")")
			currentDepth = (currentDepth == 0 ? 0 : currentDepth - 1);
		else {
			if (currentDepth > ret.depth)
				ret.depth = currentDepth;
			if (ret[currentDepth] == undefined)
				ret[currentDepth] = "";
			ret[currentDepth] += s;
		}
	}
	var compact = Object.create(null),
		nd = 0;
	for (var d = 0; d <= ret.depth; d++) {
		var l = ret[d];
		if (l != undefined) {
			compact[nd] = l;
			nd++;
		}
	}
	compact.depth = nd - 1;
	if (compact['0'] == undefined)
		compact['0'] = "";
	return compact;
};

Pu.prototype.distance = function(source, target, options) {
	options = options || Object.create(null);
	if (isNaN(options.insertion_cost)) options.insertion_cost = 1;
	if (isNaN(options.deletion_cost)) options.deletion_cost = 1;
	if (isNaN(options.substitution_cost)) options.substitution_cost = 1;

	var sourceLength = source.length;
	var targetLength = target.length;
	var distanceMatrix = [
		[0]
	];

	for (var row = 1; row <= sourceLength; row++) {
		distanceMatrix[row] = [];
		distanceMatrix[row][0] = distanceMatrix[row - 1][0] + options.deletion_cost;
	}

	for (var column = 1; column <= targetLength; column++) {
		distanceMatrix[0][column] = distanceMatrix[0][column - 1] + options.insertion_cost;
	}

	for (var row = 1; row <= sourceLength; row++) {
		for (var column = 1; column <= targetLength; column++) {
			var costToInsert = distanceMatrix[row][column - 1] + options.insertion_cost;
			var costToDelete = distanceMatrix[row - 1][column] + options.deletion_cost;

			var sourceElement = source[row - 1];
			var targetElement = target[column - 1];
			var costToSubstitute = distanceMatrix[row - 1][column - 1];
			if (sourceElement !== targetElement) {
				costToSubstitute = costToSubstitute + options.substitution_cost;
			}
			distanceMatrix[row][column] = Math.min(costToInsert, costToDelete, costToSubstitute);
		}
	}
	return distanceMatrix[sourceLength][targetLength];
};

Pu.prototype.lcs = function(str1, str2) {
	if (!str1 || !str2)
		return {
			length: 0,
			sequence: "",
			offset: 0
		};

	var sequence = "",
		str1Length = str1.length,
		str2Length = str2.length,
		num = new Array(str1Length),
		maxlen = 0,
		lastSubsBegin = 0;

	for (var i = 0; i < str1Length; i++) {
		var subArray = new Array(str2Length);
		for (var j = 0; j < str2Length; j++)
			subArray[j] = 0;
		num[i] = subArray;
	}
	var thisSubsBegin = null;
	for (var i = 0; i < str1Length; i++) {
		for (var j = 0; j < str2Length; j++) {
			if (str1[i] !== str2[j])
				num[i][j] = 0;
			else {
				if ((i === 0) || (j === 0))
					num[i][j] = 1;
				else
					num[i][j] = 1 + num[i - 1][j - 1];

				if (num[i][j] > maxlen) {
					maxlen = num[i][j];
					thisSubsBegin = i - num[i][j] + 1;
					if (lastSubsBegin === thisSubsBegin) {
						sequence += str1[i];
					} else {
						lastSubsBegin = thisSubsBegin;
						sequence = "";
						sequence += str1.substr(lastSubsBegin, (i + 1) - lastSubsBegin);
					}
				}
			}
		}
	}
	return {
		length: maxlen,
		sequence: sequence,
		offset: thisSubsBegin
	};
};

/* CSV */
// Strict
Pu.prototype.csv = function(strData, strDelimiter) {
	var me = this;
	if (strData.length < 200 && strData.indexOf('\n') < 0 && strData.indexOf('.') > 0 && strData.substr(-3).toLowerCase() == "csv")
		return me.read(strData);
	else {
		strDelimiter = (strDelimiter || ",");
		var objPattern = new RegExp(("(\\" + strDelimiter + "|\\r?\\n|\\r|^)" + "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" + "([^\"\\" + strDelimiter + "\\r\\n]*))"), "gi");
		var arrData = [
				[]
			],
			arrMatches = null;
		if (strData.length == 0) return (arrData);
		while (arrMatches = objPattern.exec(strData)) {
			var strMatchedDelimiter = arrMatches[1];
			if (strMatchedDelimiter.length && (strMatchedDelimiter != strDelimiter))
				arrData.push([]);
			if (arrMatches[2])
				var strMatchedValue = arrMatches[2].replace(new RegExp("\"\"", "g"), "\"");
			else
				var strMatchedValue = arrMatches[3];
			arrData[arrData.length - 1].push(strMatchedValue);
		}
		return arrData;
	}
};

// Special (trim quote)
Pu.prototype._csv = function(strData) {
	var me = this;
	var lines = strData.split('\n'),
		table = [],
		magic = "]_%_KeEp_&_CoMm_%_[",
		magicReg = /\]_%_KeEp_&_CoMm_%_\[/gi;
	for (var i = 0; i < lines.length; i++) {
		var line = lines[i].trim();
		if (line.length > 0) {
			var buffer = "",
				pos = 0,
				inquote = false;
			while (pos < line.length) {
				var c = line[pos];
				if (c == "\"")
					inquote = !inquote;
				else if (c == "," && inquote == true)
					buffer += magic;
				else
					buffer += c;
				pos++;
			}
			var lineData = [];
			line = buffer.replace(/\"/gi, "").split(',');
			for (var j = 0; j < line.length; j++) {
				var v = line[j].replace(magicReg, ",").trim();
				if (v.length > 0)
					lineData.push(v);
			}
			if (lineData.length > 0)
				table.push(lineData);
		}
	}
	return table;
};

/* Math */
Pu.prototype.cos = function(a, b) {
	var x = 0,
		y = 0,
		z = 0,
		len = a.length;
	if (b.length > len)
		len = b.length;
	for (var i = 0; i < len; i++) {
		var ai = a[i] || 0,
			bi = b[i] || 0;
		x += ai * bi;
		y += ai * ai;
		z += bi * bi;
	}
	return (x / (Math.sqrt(y) * Math.sqrt(z)));
};

Pu.prototype.intersect = function(x, y) {
	var ret = [];
	if (!x || !y || x.length == 0 || y.length == 0)
		return ret;
	for (var i = 0; i < x.length; i++) {
		for (var z = 0; z < y.length; z++) {
			if (x[i] == y[z]) {
				ret.push(x[i]);
				break;
			}
		}
	}
	return ret;
};

Pu.prototype.random = function(min, max) {
	return Math.random() * (max - min) + min;
};

Pu.prototype._maxmin = function(array, key, isMax) {
	var a = array[0],
		b = a;
	if (key != undefined)
		b = a[key];
	for (var i = 1; i < array.length; i++) {
		var o = array[i],
			s = o;
		if (key != undefined)
			s = o[key];
		if ((isMax == true && s > b) || (isMax == false && s < b)) {
			a = o;
			b = s;
		}
	}
	return a;
};

Pu.prototype.max = function(array, key) {
	return this._maxmin(array, key, true);
};

Pu.prototype.min = function(array, key) {
	return this._maxmin(array, key, false);
};

/* Time */
Pu.prototype.interval = function(t, defMap, noTrim) {
	var CN = {
		"ms": "毫秒",
		"s": "秒",
		"m": "分",
		"h": "小时",
		"d": "天"
	};
	if (!defMap || defMap == "en")
		defMap = {
			"ms": "ms",
			"s": "s",
			"m": "m",
			"h": "h",
			"d": "d"
		};
	else if (defMap == "cn")
		defMap = CN;
	var ms_d = 1000 * 60 * 60 * 24,
		ms_h = 1000 * 60 * 60,
		ms_m = 1000 * 60,
		ms_s = 1000;
	var d = Math.floor(t / ms_d);
	var h = Math.floor((t - d * ms_d) / ms_h);
	var m = Math.floor((t - d * ms_d - h * ms_h) / ms_m);
	var s = Math.floor((t - d * ms_d - h * ms_h - m * ms_m) / ms_s);
	var ms = Math.floor(t - d * ms_d - h * ms_h - m * ms_m - s * ms_s);

	if (noTrim == true)
		return d + defMap.d + " " + h + defMap.h + " " + m + defMap.m + " " + s + defMap.s + " " + ms + defMap.ms;
	else {
		var ret = "",
			empty = true;
		if (d > 0) {
			empty = false;
			ret += d + defMap.d;
		}
		if (h > 0 || empty == false) {
			if (empty == false)
				ret += " ";
			empty = false;
			ret += h + defMap.h;
		}
		if (m > 0 || empty == false) {
			if (empty == false)
				ret += " ";
			empty = false;
			ret += m + defMap.m;
		}
		if (s > 0 || empty == false) {
			if (empty == false)
				ret += " ";
			empty = false;
			ret += s + defMap.s;
		}
		if (ms > 0 || empty == false) {
			if (empty == false)
				ret += " ";
			empty = false;
			ret += ms + defMap.ms;
		}
		return ret;
	}
};

Pu.prototype.time = function(pre, suf) {
	if (!pre)
		pre = '';
	if (!suf)
		suf = '';
	var date = new Date();
	var year = date.getFullYear();
	var month = date.getMonth() + 1;
	var day = date.getDate();
	if (month < 10) month = '0' + month;
	if (day < 10) day = '0' + day;
	var hour = date.getHours();
	if (hour < 10) hour = '0' + hour;
	var minute = date.getMinutes();
	if (minute < 10) minute = '0' + minute;
	var second = date.getSeconds();
	if (second < 10) second = '0' + second;
	var str = pre + year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second + suf;
	return str;
};

Pu.prototype.stopwatch = function(sid, raw) {
	var me = this;
	if (me.__stopwatchbag == undefined)
		me.__stopwatchbag = Object.create(null);
	if (me.__stopwatchbag[sid] == undefined) {
		me.__stopwatchbag[sid] = Date.now();
		if (raw == true)
			return 0;
		else
			return me.interval(0);
	} else {
		var now = Date.now();
		if (raw == true)
			return (now - me.__stopwatchbag[sid]);
		else
			return me.interval(now - me.__stopwatchbag[sid]);
	}
};

/* File System */
var isWindows = (process.platform === "win32")

var mkdirA = function(p, opts, f, made) {
	if (typeof opts === 'function') {
		f = opts;
		opts = Object.create(null);
	} else if (!opts || typeof opts !== 'object')
		opts = {
			mode: opts
		};
	var mode = opts.mode,
		xfs = opts.fs || fs;
	if (mode === undefined)
		mode = 0777 & (~process.umask());
	if (!made) made = null;
	var cb = f || function() {};
	p = path.resolve(p);
	xfs.mkdir(p, mode, function(er) {
		if (!er) {
			made = made || p;
			return cb(null, made);
		}
		switch (er.code) {
			case 'ENOENT':
				mkdirA(path.dirname(p), opts, function(er, made) {
					if (er) cb(er, made);
					else mkdirA(p, opts, cb, made);
				});
				break;
			default:
				xfs.stat(p, function(er2, stat) {
					if (er2 || !stat.isDirectory()) cb(er, made)
					else cb(null, made);
				});
				break;
		}
	});
};

var mkdirS = function(p, opts, made) {
	if (!opts || typeof opts !== 'object')
		opts = {
			mode: opts
		};

	var mode = opts.mode,
		xfs = opts.fs || fs;

	if (mode === undefined)
		mode = 0777 & (~process.umask());
	if (!made) made = null;
	p = path.resolve(p);
	try {
		xfs.mkdirSync(p, mode);
		made = made || p;
	} catch (err0) {
		switch (err0.code) {
			case 'ENOENT':
				made = mkdirS(path.dirname(p), opts, made);
				mkdirS(p, opts, made);
				break;
			default:
				var stat;
				try {
					stat = xfs.statSync(p);
				} catch (err1) {
					throw err0;
				}
				if (!stat.isDirectory()) throw err0;
				break;
		}
	}
	return made;
};

// @[Isaac Z. Schlueter](https://github.com/isaacs "isaacs") [rimraf](https://github.com/isaacs/rimraf "rimraf")
var timeout = 0,
	EMFILE_MAX = 1000;

function rimdefaults(options) {
	var methods = [
		'unlink',
		'chmod',
		'stat',
		'rmdir',
		'readdir'
	]
	methods.forEach(function(m) {
		options[m] = options[m] || fs[m]
		m = m + 'Sync'
		options[m] = options[m] || fs[m]
	})
}

function rimraf(p, options, cb) {
	if (typeof options === 'function') {
		cb = options
		options = {}
	}
	rimdefaults(options)

	if (!cb) throw new Error("No callback passed to rimraf()")

	var busyTries = 0
	rimraf_(p, options, function CB(er) {
		if (er) {
			if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY") &&
				busyTries < 3) {
				busyTries++
				var time = busyTries * 100
				return setTimeout(function() {
					rimraf_(p, options, CB)
				}, time)
			}

			if (er.code === "EMFILE" && timeout < EMFILE_MAX) {
				return setTimeout(function() {
					rimraf_(p, options, CB)
				}, timeout++)
			}

			if (er.code === "ENOENT") er = null
		}
		timeout = 0
		cb(er)
	})
}

function rimraf_(p, options, cb) {
	options.unlink(p, function(er) {
		if (er) {
			if (er.code === "ENOENT")
				return cb(null)
			if (er.code === "EPERM")
				return (isWindows) ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb)
			if (er.code === "EISDIR")
				return rmdir(p, options, er, cb)
		}
		return cb(er)
	})
}

function fixWinEPERM(p, options, er, cb) {
	options.chmod(p, 666, function(er2) {
		if (er2)
			cb(er2.code === "ENOENT" ? null : er)
		else
			options.stat(p, function(er3, stats) {
				if (er3)
					cb(er3.code === "ENOENT" ? null : er)
				else if (stats.isDirectory())
					rmdir(p, options, er, cb)
				else
					options.unlink(p, cb)
			})
	})
}

function fixWinEPERMSync(p, options, er) {
	try {
		options.chmodSync(p, 666)
	} catch (er2) {
		if (er2.code === "ENOENT")
			return
		else
			throw er
	}

	try {
		var stats = options.statSync(p)
	} catch (er3) {
		if (er3.code === "ENOENT")
			return
		else
			throw er
	}

	if (stats.isDirectory())
		rmdirSync(p, options, er)
	else
		options.unlinkSync(p)
}

function rmdir(p, options, originalEr, cb) {
	options.rmdir(p, function(er) {
		if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
			rmkids(p, options, cb)
		else if (er && er.code === "ENOTDIR")
			cb(originalEr)
		else
			cb(er)
	})
}

function rmkids(p, options, cb) {
	options.readdir(p, function(er, files) {
		if (er)
			return cb(er)
		var n = files.length
		if (n === 0)
			return options.rmdir(p, cb)
		var errState
		files.forEach(function(f) {
			rimraf(path.join(p, f), options, function(er) {
				if (errState)
					return
				if (er)
					return cb(errState = er)
				if (--n === 0)
					options.rmdir(p, cb)
			})
		})
	})
}

function rimrafSync(p, options) {
	options = options || {}
	rimdefaults(options)
	try {
		options.unlinkSync(p)
	} catch (er) {
		if (er.code === "ENOENT")
			return
		if (er.code === "EPERM")
			return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
		if (er.code !== "EISDIR")
			throw er
		rmdirSync(p, options, er)
	}
}

function rmdirSync(p, options, originalEr) {
	try {
		options.rmdirSync(p)
	} catch (er) {
		if (er.code === "ENOENT")
			return
		if (er.code === "ENOTDIR")
			throw originalEr
		if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
			rmkidsSync(p, options)
	}
}

function rmkidsSync(p, options) {
	options.readdirSync(p).forEach(function(f) {
		rimrafSync(path.join(p, f), options)
	})
	options.rmdirSync(p, options)
}

Pu.prototype.dir = function(fd, type, callback) {
	if (typeof(type) == "function") {
		callback = type;
		type = null;
	}
	var filter = function(ffiles, ftype) {
		if (typeof(ftype) == "string")
			ftype = [ftype.toLowerCase()];
		var matched = [];
		for (var i = 0; i < ffiles.length; i++) {
			if (ftype.indexOf(ffiles[i].split('.').pop().toLowerCase()) >= 0)
				matched.push(ffiles[i]);
		}
		return matched;
	};
	if (callback) {
		fs.readdir(fd, function(err, files) {
			if (err || !files)
				callback([]);
			else if (!type)
				callback((files == null ? [] : files));
			else
				callback(filter(files, type));
			return;
		});
	} else {
		var files = null;
		try {
			files = fs.readdirSync(fd);
		} catch (e) {
			return [];
		}
		if (!type || files == null)
			return (files == null ? [] : files);
		return filter(files, type);
	}
};

Pu.prototype.ls = Pu.prototype.dir;

Pu.prototype.mkdir = function(fd, opts, callback) {
	if (fd && fd.length > 0) {
		if (typeof(opts) == "function") {
			callback = opts;
			opts = undefined;
		}
		if (callback)
			mkdirA(fd, opts, callback);
		else
			mkdirS(fd, opts);
	}
};

Pu.prototype.isdir = function(fd, callback) {
	if (callback) {
		fs.stat(fd, function(err, stat) {
			if (!stat || stat.isDirectory() == false)
				callback(false);
			else
				callback(true);
		});
	} else {
		var stat = fs.statSync(fd);
		if (stat.isDirectory())
			return true;
		else
			return false;
	}
}

Pu.prototype.mv = function(oldPath, newPath, callback) {
	if (callback) {
		fs.rename(oldPath, newPath, callback);
	} else {
		return fs.renameSync(oldPath, newPath);
	}
};

Pu.prototype.rm = function(fd, callback) {
	if (callback)
		rimraf(fd, callback);
	else
		rimrafSync(fd);
};

Pu.prototype.byline = function(fd, onLine, onEnd) {
	var me = this;
	var Transform = require('stream').Transform;

	function lineReader() {
		Transform.call(this);
		this.buffer = '';
		this._readableState.objectMode = true;
		this.on('pipe', function(src) {
			this.encoding = src._readableState.encoding;
		});
	}

	lineReader.prototype = Object.create(Transform.prototype);

	lineReader.prototype._transform = function(chunk, encoding, cb) {
		var pieces = (this.buffer + chunk.toString('utf8')).split('\n');
		this.buffer = pieces.pop();
		for (var i = 0; i < pieces.length; i += 1)
			this.push(pieces[i]);
		cb();
	};

	lineReader.prototype._flush = function(cb) {
		this.push(this.buffer);
		cb();
	};

	var reader = new lineReader();

	require('fs').createReadStream(fd, {
		'encoding': 'utf8'
	}).pipe(reader);

	if (onLine)
		reader.on('data', onLine);

	if (onEnd)
		reader.on('end', onEnd);
};

Pu.prototype.write = function(fd, data, callback) {
	var me = this;
	var fileType = fd.split('.').pop().toLowerCase();
	var directory = fd.substr(0, fd.lastIndexOf('/') + 1);
	var dataStr = "";
	if (typeof(data) == "object") {
		if (fileType == "csv") {
			if (data.length == undefined) {
				var data2 = [];
				for (var key in data)
					data2.push([key, data[key]]);
				data = data2;
			}
			for (var i = 0; i < data.length; i++) {
				var line = "";
				if (i > 0)
					line += "\n";
				for (var j = 0; j < data[i].length; j++) {
					var w = data[i][j] + "";
					if (w.indexOf(',') >= 0)
						w = "\"" + w + "\"";
					if (j > 0)
						line += ",";
					line += w;
				}
				dataStr += line;
			}
		} else if (fileType == "dict")
			dataStr = data.join('\n');
		else
			dataStr = me.pretty(data);
	} else
		dataStr = data;
	if (callback) {
		me.mkdir(directory, function() {
			fs.writeFile(fd, dataStr, callback);
		});
	} else {
		me.mkdir(directory);
		fs.writeFileSync(fd, dataStr);
	}
};

Pu.prototype.read = function(fd, rawMode, callback) {

	if (typeof(rawMode) == "function") {
		callback = rawMode;
		rawMode = false;
	}

	var me = this;
	var fileType = fd.split('.').pop().toLowerCase();

	var fileDataWithType = function(data, type) {
		if (type == "txt" || type == "js" || type == "log")
			return data.toString();
		else if (type == "dict")
			return data.toString().split('\n');
		else if (type == "csv")
			return me.csv(data.toString());
		else if (type == "json")
			return JSON.parse(data.toString());
		else
			return data;
	};

	if (callback) {
		fs.readFile(fd, function(err, data) {
			if (err || !data)
				callback(null);
			else if (rawMode == true)
				callback(data);
			else
				callback(fileDataWithType(data, fileType));
			return;
		});
	} else {
		var data = fs.readFileSync(fd);
		if (!data)
			return null;
		if (rawMode == true)
			return data;
		return fileDataWithType(data, fileType);
	}
};

Pu.prototype.where = function(fd, searchPaths) {
	for (var i = 0; i < searchPaths.length; i++) {
		var found = false;
		try {
			var stats = fs.statSync(searchPaths[i] + fd);
			if (stats && stats.isFile() == true)
				found = true;
		} catch (e) {

		}
		if (found)
			return searchPaths[i] + fd;
	}
	return null;
};

Pu.prototype.walk = function(fd) {
	var me = this;
	if (fd[fd.length - 1] == '/')
		fd = fd.substr(0, fd.length - 1);

	var walk = function(path) {
		var buffer = [];
		var fns = me.dir(path);
		for (var i = 0; i < fns.length; i++) {
			var fullPath = path + '/' + fns[i];
			if (me.isdir(fullPath))
				buffer = buffer.concat(walk(fullPath));
			else
				buffer.push(fullPath);
		}
		return buffer;
	};

	var files = walk(fd);
	return files;
};

Pu.prototype.path = function(from, to) {
	var pathUtil = require("path");
	if (to == undefined) {
		to = from;
		from = '.';
	}
	return pathUtil.resolve(from, to);
};

/* Parsing */
Pu.prototype.sax = function(str, delimiters, emitCallback) {
	var buffer = "",
		escapeNext = false,
		prevTag = "__START__";
	var emit = function(newTag) {
		buffer = buffer.trim();
		emitCallback(buffer, newTag, prevTag);
		prevTag = newTag;
		buffer = "";
	};
	for (var i = 0; i < str.length; i++) {
		if (str[i] == '\\' && escapeNext == false)
			escapeNext = true;
		else {
			if (escapeNext == false) {
				var emitted = false;
				for (var j = 0; j < delimiters.length; j++) {
					var d = delimiters[j],
						dl = d.length;
					if (str.substr(i, dl) == d) {
						emitted = true;
						emit(d);
						i += dl - 1;
						break;
					}
				}
				if (emitted == false)
					buffer += str[i];
			} else {
				escapeNext = false;
				buffer += str[i];
			}
		}
	}
	emit("__END__");
};

/* Object helper */
function objectToString(o) {
	return Object.prototype.toString.call(o);
}

Pu.prototype.isArray = function(ar) {
	return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
};

Pu.prototype.isDate = function(d) {
	return typeof d === 'object' && objectToString(d) === '[object Date]';
};

Pu.prototype.isRegExp = function(re) {
	return typeof re === 'object' && objectToString(re) === '[object RegExp]';
};

Pu.prototype._getRegExpFlags = function(re) {
	var flags = '';
	re.global && (flags += 'g');
	re.ignoreCase && (flags += 'i');
	re.multiline && (flags += 'm');
	return flags;
};

Pu.prototype.type = function(data) {
	var me = this;
	var t = (typeof(data)).toLowerCase();
	if (t != "object")
		return t;
	else {
		if (me.isArray(data))
			return "array";
		else if (me.isDate(data))
			return "date";
		else if (me.isRegExp(data))
			return "regexp";
		else if (Buffer.isBuffer(data))
			return "buffer";
		else
			return "object";
	}
};

Pu.prototype.extend = function(src, ext, noOverwirte) {
	var me = this;
	var st = me.type(src),
		et = me.type(ext);
	if (st == "array") {
		if (et == "array") {
			if (noOverwirte == true)
				src = src.concat(ext);
			else {
				for (var i = 0; i < ext.length; i++) {
					if (src.indexOf(ext[i]) < 0)
						src.push(ext[i]);
				}
			}
		} else if (noOverwirte == true || src.indexOf(ext) < 0)
			src.push(ext);
		return src;
	} else if (st == "object" && et == "object") {
		for (var k in ext) {
			if (noOverwirte != true || src[k] == undefined)
				src[k] = ext[k];
		}
		return src;
	} else
		return src;
};

Pu.prototype.dedup = function(array, safeMode) {
	if (safeMode != true) {
		var reg = Object.create(null),
			ret = [];
		for (var i = 0; i < array.length; i++)
			reg[array[i]] = 0;
		for (var k in reg)
			ret.push(k);
		return ret;
	} else {
		var a = array.concat();
		for (var i = 0; i < a.length; ++i) {
			for (var j = i + 1; j < a.length; ++j) {
				if (a[i] === a[j])
					a.splice(j--, 1);
			}
		}
		return a;
	}
};

Pu.prototype.remove = function(array, index) {
	if (index > -1)
		array.splice(index, 1);
	return array;
};

Pu.prototype.filter = function(array, filter) {
	var fmode = false,
		me = this;
	if (typeof(filter) == "function")
		fmode = true;
	var len = array.length;
	for (var i = len - 1; i >= 0; i--) {
		if ((fmode == true && filter(array[i]) == false) || (fmode == false && array[i] == filter))
			me.remove(array, i);
	}
	return array;
};

Pu.prototype.flat = function(array, key) {
	var na = [];
	for (var i = 0; i < array.length; i++)
		na.push(array[i][key]);
	return na;
};

Pu.prototype.clone = function(parent, circular, depth, prototype) {
	var me = this;
	var allParents = [];
	var allChildren = [];

	var useBuffer = typeof Buffer != 'undefined';

	if (typeof circular == 'undefined')
		circular = true;

	if (typeof depth == 'undefined')
		depth = Infinity;

	function _clone(parent, depth) {

		if (parent === null)
			return null;

		if (depth == 0)
			return parent;

		var child;
		if (typeof parent != 'object') {
			return parent;
		}

		if (me.isArray(parent)) {
			child = [];
		} else if (me.isRegExp(parent)) {
			child = new RegExp(parent.source, me._getRegExpFlags(parent));
			if (parent.lastIndex) child.lastIndex = parent.lastIndex;
		} else if (me.isDate(parent)) {
			child = new Date(parent.getTime());
		} else if (useBuffer && Buffer.isBuffer(parent)) {
			child = new Buffer(parent.length);
			parent.copy(child);
			return child;
		} else {
			if (typeof prototype == 'undefined') child = Object.create(Object.getPrototypeOf(parent));
			else child = Object.create(prototype);
		}

		if (circular) {
			var index = allParents.indexOf(parent);

			if (index != -1) {
				return allChildren[index];
			}
			allParents.push(parent);
			allChildren.push(child);
		}

		for (var i in parent) {
			child[i] = _clone(parent[i], depth - 1);
		}

		return child;
	}

	return _clone(parent, depth);
}

/* Crypto helper*/
Pu.prototype.hash = function(data, algorithm, saltFunc, output) {
	if (typeof(saltFunc) != "function") {
		output = saltFunc;
		saltFunc = undefined;
	}
	if (algorithm == undefined)
		algorithm = 'md5';
	else
		algorithm = algorithm.toLowerCase();
	if (output == undefined)
		output = 'hex';
	else
		output = output.toLowerCase();
	var s = require("crypto").createHash(algorithm);
	var d = data;
	if (saltFunc != undefined)
		d = saltFunc(data);
	s.update(d);
	return (s.digest(output));
};

/* Cheerio helper */
Pu.prototype.$ = function(html, cheerio, decodeEntities) {
	if (cheerio == undefined)
		cheerio = require("cheerio");
	if (decodeEntities == undefined)
		decodeEntities = false;
	return cheerio.load(html, {
		decodeEntities: decodeEntities
	});
};

/* Express helpers */
Pu.prototype.app = function(staticDir, publicDir) {
	var express = require('express');
	var app = express();
	if (staticDir != undefined)
		app.use(express.static(staticDir));
	if (publicDir != undefined) {
		var directory = require('serve-index');
		app.use(directory(publicDir));
	}
	app.disable('x-powered-by');
	app.disable('x-server');
	app.disable('server');
	return app;
};

Pu.prototype.server = function(port, handler, sslOptions, useLog) {
	var me = this;
	var http = require('http'),
		https = require('https');
	if (http.globalAgent && http.globalAgent.maxSockets && http.globalAgent.maxSockets < 100)
		http.globalAgent.maxSockets = 100;
	var server;
	if (sslOptions)
		server = https.createServer(sslOptions, handler);
	else
		server = http.createServer(handler);
	server.listen(port, function() {
		if (useLog != false)
			me.log('[Pu]' + ' HTTP' + (sslOptions ? 'S' : '') + ' server listening on port ' + port + '.', true);
	});
	server._PU_last_port = port;
	server.resume = function(cb) {
		if (this._PU_last_port != undefined)
			this.listen(this._PU_last_port, cb);
	};
	return server;
};

Pu.prototype.notfound = function(app, redirectPath) {
	app.use(function(req, res) {
		res.redirect(redirectPath);
	});
	app.use(function(error, req, res, next) {
		res.redirect(redirectPath);
	});
};

Pu.prototype.forceSecure = function(defaultHost, useLog) {
	var me = this;
	if (!defaultHost)
		defaultHost = 'www.peak-labs.com';
	var express = require('express'),
		http = require('http');
	var redirectHandler = express();
	redirectHandler.use(function(req, res) {
		if (!req.secure) {
			var hostWithoutPort = defaultHost;
			if (req.headers.host)
				hostWithoutPort = req.headers.host.split(':')[0]
			return res.redirect(301, 'https://' + hostWithoutPort + req.url);
		}
	});
	http.createServer(redirectHandler).listen(80, function() {
		if (useLog != false)
			me.log('[Pu]' + ' Redirecting all HTTP requests to HTTPS!', true);
	});
};

Pu.prototype.params = function(req) {
	if (req._PU_parsed != undefined)
		return req._PU_parsed;
	var parsed = Object.create(null);
	var haveParam = false;
	if (req.query) {
		for (var key in req.query) {
			parsed[key] = req.query[key];
			haveParam = true;
		}
	}
	if (req.body && typeof(req.body) == "object") {
		for (var key in req.body) {
			parsed[key] = req.body[key];
			haveParam = true;
		}
	}
	if (haveParam) {
		req._PU_parsed = parsed;
		return parsed;
	} else {
		req._PU_parsed = null;
		return null;
	}
};

Pu.prototype.basicAuth = function(accounts) {
	accounts = accounts != null ? accounts : {};
	return function(req, res, next) {
		var auth, buf, creds, found, i, password, tmp, userAuth, username;
		auth = req.headers['authorization'];
		if (!auth) {
			res.statusCode = 401;
			res.setHeader('WWW-Authenticate', 'Basic realm="Secure Area"');
			return res.end();
		} else {
			tmp = auth.split(' ');
			buf = new Buffer(tmp[1], 'base64');
			userAuth = buf.toString();
			creds = userAuth.split(':');
			username = creds[0];
			password = creds[1];
			found = false;
			for (i in accounts) {
				if (username === i && password === accounts[i]) {
					found = true;
				}
			}
			if (found) {
				res.statusCode = 200;
				return next();
			} else {
				res.statusCode = 401;
				res.setHeader('WWW-Authenticate', 'Basic realm="Secure Area"');
				return res.end();
			}
		}
	};
};

Pu.prototype.headers = function(referer, origin, ua) {
	var template = {
		"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
		"User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit/537.78.2 (KHTML, like Gecko) Version/7.0.6 Safari/537.78.2",
		"Content-Type": "application/x-www-form-urlencoded"
	};
	if (referer)
		template["Referer"] = referer;
	if (origin)
		template["Origin"] = origin;
	if (ua) {
		if (ua.toLowerCase() == "mobile" || ua.toLowerCase() == "iphone")
			template["User-Agent"] = "Mozilla/5.0 (iPhone; CPU iPhone OS 7_0 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11A465 Safari/9537.53";
		else
			template["User-Agent"] = ua;
	}
	return template;
};

// @[Rodrigo Guerreiro](https://github.com/rguerreiro "rguerreiro") [express-device](https://github.com/rguerreiro/express-device "express-device")
Pu.prototype.device = function(ua) {
	if (!ua || ua === '')
		return 'unknown';
	if (ua.match(/GoogleTV|SmartTV|Internet TV|NetCast|NETTV|AppleTV|boxee|Kylo|Roku|DLNADOC|CE\-HTML/i))
		return 'tv';
	else if (ua.match(/Xbox|PLAYSTATION|Wii/i))
		return 'tv';
	else if (ua.match(/iP(a|ro)d/i) || (ua.match(/tablet/i) && !ua.match(/RX-34/i)) || ua.match(/FOLIO/i))
		return 'tablet';
	else if (ua.match(/Linux/i) && ua.match(/Android/i) && !ua.match(/Fennec|mobi|HTC Magic|HTCX06HT|Nexus One|SC-02B|fone 945/i))
		return 'tablet';
	else if (ua.match(/Kindle/i) || (ua.match(/Mac OS/i) && ua.match(/Silk/i)) || (ua.match(/AppleWebKit/i) && ua.match(/Silk/i) && !ua.match(/Playstation Vita/i)))
		return 'tablet';
	else if (ua.match(/GT-P10|SC-01C|SHW-M180S|SGH-T849|SCH-I800|SHW-M180L|SPH-P100|SGH-I987|zt180|HTC( Flyer|_Flyer)|Sprint ATP51|ViewPad7|pandigital(sprnova|nova)|Ideos S7|Dell Streak 7|Advent Vega|A101IT|A70BHT|MID7015|Next2|nook/i) || (ua.match(/MB511/i) && ua.match(/RUTEM/i)))
		return 'tablet';
	else if (ua.match(/BOLT|Fennec|Iris|Maemo|Minimo|Mobi|mowser|NetFront|Novarra|Prism|RX-34|Skyfire|Tear|XV6875|XV6975|Google Wireless Transcoder/i))
		return 'phone';
	else if (ua.match(/Opera/i) && ua.match(/Windows NT 5/i) && ua.match(/HTC|Xda|Mini|Vario|SAMSUNG\-GT\-i8000|SAMSUNG\-SGH\-i9/i))
		return 'phone';
	else if ((ua.match(/Windows (NT|XP|ME|9)/) && !ua.match(/Phone/i)) && !ua.match(/Bot|Spider|ia_archiver|NewsGator/i) || ua.match(/Win( ?9|NT)/i))
		return 'desktop';
	else if (ua.match(/Macintosh|PowerPC/i) && !ua.match(/Silk/i))
		return 'desktop';
	else if (ua.match(/Linux/i) && ua.match(/X11/i) && !ua.match(/Charlotte/i))
		return 'desktop';
	else if (ua.match(/CrOS/))
		return 'desktop';
	else if (ua.match(/Solaris|SunOS|BSD/i))
		return 'desktop';
	else if (ua.match(/curl|Bot|B-O-T|Crawler|Spider|Spyder|Yahoo|ia_archiver|Covario-IDS|findlinks|DataparkSearch|larbin|Mediapartners-Google|NG-Search|Snappy|Teoma|Jeeves|Charlotte|NewsGator|TinEye|Cerberian|SearchSight|Zao|Scrubby|Qseero|PycURL|Pompos|oegp|SBIder|yoogliFetchAgent|yacy|webcollage|VYU2|voyager|updated|truwoGPS|StackRambler|Sqworm|silk|semanticdiscovery|ScoutJet|Nymesis|NetResearchServer|MVAClient|mogimogi|Mnogosearch|Arachmo|Accoona|holmes|htdig|ichiro|webis|LinkWalker|lwp-trivial|facebookexternalhit/i) && !ua.match(/phone|Playstation/i))
		return 'bot';
	else
		return 'phone';
};

/* Cluster and Process */
var cluster = null;

Pu.prototype._execall = function(pack) {
	var me = this;
	var name = pack.name;
	if (me.__BINDS != undefined && typeof(me.__BINDS[name]) == "function")
		me.__BINDS[name](pack.data, pack.senderId);
};

Pu.prototype._exemaster = function(pack) {
	if (cluster == null)
		cluster = require('cluster');
	var me = this,
		receiverId = pack.receiverId;
	if (receiverId == me.__MASTERID || receiverId == 0) {
		if (pack.name == "_PU_wid_change_" && pack.data.from != undefined && pack.data.to != undefined) {
			for (var j in cluster.workers) {
				if (cluster.workers[j].id == pack.data.from)
					cluster.workers[j].id = pack.data.to;
			}
		} else
			me._execall(pack);
	} else {
		for (var j in cluster.workers) {
			if (receiverId == undefined || receiverId == cluster.workers[j].id)
				cluster.workers[j].send(pack);
		}
	}
};

Pu.prototype.fork = function(workerCallback, masterCallback, threads, useLog) {
	if (typeof(masterCallback) == "number") {
		useLog = threads;
		threads = masterCallback;
		masterCallback = undefined;
	}
	var me = this;
	if (cluster == null)
		cluster = require('cluster');
	if (threads == undefined || threads == 0)
		threads = require('os').cpus().length;
	cluster.on('exit', function(worker) {
		if (worker.suicide != true) {
			if (useLog != false)
				me.log('[ERROR] [Pu]' + ' Worker ' + (worker.id) + ' died, respawning...', true);
			cluster.fork();
		} else {
			if (useLog != false)
				me.log('[Pu]' + ' Worker ' + (worker.id) + ' ended.', true);
		}
	});
	if (cluster.isMaster) {
		me.__MASTERID = 0;
		if (useLog != false)
			me.log('[Pu]' + " Starting " + threads + " workers (threads) ...", true);
		for (var i = 0; i < threads; i++) {
			var w = cluster.fork();
			w.on('message', function(pack) {
				me._exemaster(pack);
			});
		}
		if (masterCallback)
			masterCallback(threads);
	} else if (cluster.isWorker) {
		process.on('message', function(pack) {
			me._execall(pack);
		});
		if (workerCallback)
			workerCallback(cluster.worker.id, threads);
	}
};

Pu.prototype.tell = function(receiverId, notificationName, data) {
	var me = this;
	if (cluster == null)
		cluster = require('cluster');
	var senderId = 0;
	if (cluster.isWorker)
		senderId = cluster.worker.id;
	var pack = {
		data: data,
		senderId: senderId,
		name: notificationName
	};
	if (receiverId != undefined)
		pack.receiverId = receiverId;
	if (cluster.isMaster)
		me._exemaster(pack);
	else if (cluster.isWorker)
		process.send(pack);
};

Pu.prototype.shout = function(notificationName, data) {
	this.tell(undefined, notificationName, data);
};

Pu.prototype.heard = function(notificationName, callback) {
	var me = this;
	if (me.__BINDS == undefined)
		me.__BINDS = Object.create(null);
	me.__BINDS[notificationName] = callback;
};

Pu.prototype.hear = Pu.prototype.heard;
Pu.prototype.bind = Pu.prototype.heard;

Pu.prototype.argv = function(paramMap, lowerCase, skip) {
	if (paramMap == undefined)
		paramMap = Object.create(null);
	if (lowerCase == undefined)
		lowerCase = false;
	if (skip == undefined)
		skip = 2;
	var a = process.argv.slice(skip),
		options = {},
		currentKey = null,
		currentData = null,
		paramLeft = 0;
	for (var i = 0; i < a.length; i++) {
		var s = a[i],
			key = s;
		if (lowerCase)
			key = s.toLowerCase();
		if (paramLeft == 0) {
			if (currentKey != null && currentData != null)
				options[currentKey] = (currentData.length <= 1 ? currentData[0] : currentData);
			currentKey = null;
			currentData = null;
			var paramLength = paramMap[s];
			if (paramLength == undefined || paramLength == 0)
				options[key] = true;
			else {
				currentKey = key;
				currentData = [];
				paramLeft = paramLength;
			}
		} else {
			currentData.push(s);
			paramLeft--;
		}
	}
	if (currentKey != null && currentData != null)
		options[currentKey] = (currentData.length <= 1 ? currentData[0] : currentData);
	return options;
};

Pu.prototype.wid = function(workerID) {
	if (cluster == null)
		cluster = require('cluster');
	var me = this;
	if (cluster.isWorker) {
		if (workerID != undefined && workerID != cluster.worker.id) {
			me.tell(0, '_PU_wid_change_', {
				from: cluster.worker.id,
				to: workerID
			});
			cluster.worker.id = workerID;
		}
		return cluster.worker.id;
	} else if (cluster.isMaster) {
		if (workerID != undefined)
			me.__MASTERID = workerID;
		return me.__MASTERID;
	}
	return -1;
};

Pu.prototype.pid = function() {
	return process.pid;
};

Pu.prototype.gid = function(groupID) {
	if (process.getgid) {
		if (groupID == undefined)
			return process.getgid();
		else
			process.setgid(groupID);
	} else
		return null;
};

Pu.prototype.uid = function(userID) {
	if (process.getuid) {
		if (userID == undefined)
			return process.getuid();
		else
			process.setuid(userID);
	} else
		return null;
};

Pu.prototype.tid = function(titleID) {
	if (titleID != undefined)
		process.title = titleID;
	return process.title;
};

Pu.prototype.exit = function() {
	if (cluster == null)
		cluster = require('cluster');
	if (cluster.isWorker)
		cluster.worker.kill();
	else
		process.exit();
};

/* MongoDB helper */
Pu.prototype.mongo = function(server, useLog) {
	var me = this;
	var mongojs = require('mongojs');
	var db = mongojs(server);
	db.on('error', function(err) {
		if (useLog != false)
			me.log(err, true);
	});
	return db;
};

/* Async helper */
Pu.prototype.batch = function(inputs, func, concur, callback) {
	if (typeof(concur) == "function") {
		callback = concur;
		concur = 5;
	}
	var async = require("async");
	async.mapLimit(inputs, concur, func, function(err, results) {
		if (callback)
			callback(results);
	});
};

/* Minify Helper */
Pu.prototype.minify = function(data, type) {
	var me = this,
		ret = "";
	type = type.toLowerCase();
	if (type == "html") {
		var minifyOption = {
			removeComments: true,
			removeCommentsFromCDATA: true,
			collapseWhitespace: true,
			collapseBooleanAttributes: true,
			removeAttributeQuotes: true,
			removeRedundantAttributes: true,
			useShortDoctype: true,
			removeOptionalTags: true
		};
		var minify = require('html-minifier').minify;
		ret = minify(data, minifyOption);
	} else if (type == "js" || type == "javascript") {
		var UglifyJS = require("uglify-js");
		ret = UglifyJS.minify(data, {
			fromString: true
		}).code;
	} else if (type == "css") {
		var CleanCSS = require('clean-css');
		ret = new CleanCSS().minify(data);
	}
	return ret;
};

/* IP addresses and URL */
Pu.prototype.url = function(from, to) {
	try {
		var urlUtil = require("url");
		var protocalIndex = from.indexOf("://");
		if (protocalIndex < 0 || protocalIndex > 8)
			from = "http://" + from;
		var url = urlUtil.resolve(from, to);
		return url;
	} catch (e) {
		return from;
	}
};

Pu.prototype.ip = function() {
	var os = require('os');
	var ifaces = os.networkInterfaces();
	var ret = {
		internal: null,
		external: null,
		ipv4: {
			internal: null,
			external: null
		},
		ipv6: {
			internal: null,
			external: null
		}
	};
	for (var key in ifaces) {
		var lists = ifaces[key];
		for (var i = 0; i < lists.length; i++) {
			var record = lists[i];
			if (record.family.toLowerCase() == "ipv4") {
				if (record.internal == true) {
					if (ret.internal == null) {
						ret.internal = record.address;
						ret.ipv4.internal = record.address;
					}
				} else {
					if (ret.external == null) {
						ret.external = record.address;
						ret.ipv4.external = record.address;
					}
				}
			} else {
				if (record.internal == true) {
					if (ret.ipv6.internal == null)
						ret.ipv6.internal = record.address;
				} else {
					if (ret.ipv6.external == null)
						ret.ipv6.external = record.address;
				}
			}
		}
	}
	return ret;
};

/* Request helpers */

Pu.prototype.download = function(url, fd, options, callback) {
	var me = this,
		fired = false;
	var request = require("request");
	if (!url)
		return;
	if (typeof(fd) == "function") {
		options = {};
		callback = fd;
		fd = null;
	} else if (typeof(fd) == "object") {
		callback = options;
		options = fd;
		fd = null;
	} else if (typeof(options) == "function") {
		callback = options;
		options = {};
	}
	if (!options)
		options = {};
	options.url = url;
	var r = request(options);
	if (fd == null)
		fd = url.replace(/\/$/gi, '').split('/').pop();
	else {
		var dpath = fd.split('/');
		dpath.pop();
		me.mkdir(dpath.join('/'));
	}
	var success = function() {
		if (fired == false) {
			fired = true;
			if (callback)
				callback(true);
		}
	};
	var failed = function() {
		if (fired == false) {
			fired = true;
			if (callback)
				callback(false);
		}
	};
	r.pipe(fs.createWriteStream(fd));
	r.on('end', success);
	r.on('error', failed);
};

/* Exports */
module.exports = new Pu();